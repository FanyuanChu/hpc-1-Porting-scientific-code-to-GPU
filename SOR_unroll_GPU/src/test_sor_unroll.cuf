! test_sor_unroll.cuf
program test_sor_unroll
use cudafor
use sor_params
use sor_routines
real, allocatable, device :: p0(:,:,:), p1(:,:,:), rhs(:,:,:), p2(:,:,:), p3(:,:,:), p4(:,:,:)
real, allocatable :: host_p0(:,:,:)
integer :: iter, niters, i, j, k
integer :: clock_rate
integer, dimension(0:1) :: timestamp

allocate(p0(0:im+1,0:jm+1,0:km+1))
allocate(p1(0:im+1,0:jm+1,0:km+1))
allocate(rhs(0:im+1,0:jm+1,0:km+1))
allocate(p2(0:im+1,0:jm+1,0:km+1))
allocate(p3(0:im+1,0:jm+1,0:km+1))
allocate(p4(0:im+1,0:jm+1,0:km+1))
allocate(host_p0(0:im+1,0:jm+1,0:km+1))

do i = 0,im+1
    do j = 0,jm+1
        do k = 0,km+1
            rhs(i,j,k) = 1.0
            p0(i,j,k) = 1.0
        end do
    end do
end do

niters = 12/4
call system_clock(timestamp(0), clock_rate)

do iter = 1,niters
    print *,iter
    call sor<<<gridDim, blockDim>>>(p0,p1,rhs)
    !call cudaDeviceSynchronize()
    !call cudaThreadSynchronize()

    call sor<<<gridDim, blockDim>>>(p1,p2,rhs)
    !call cudaDeviceSynchronize()
    !call cudaThreadSynchronize()

    call sor<<<gridDim, blockDim>>>(p2,p3,rhs)
    !call cudaThreadSynchronize()

    call sor<<<gridDim, blockDim>>>(p3,p4,rhs)
    !call cudaThreadSynchronize()
    p0 = p4
end do

call system_clock(timestamp(1), clock_rate)
host_p0 = p0
print '(f8.3)',(timestamp(1)-timestamp(0))/ real(clock_rate)
print *, host_p0(im/2,jm/2,km/2)

deallocate(p0)
deallocate(p1)
deallocate(rhs)
deallocate(p2)
deallocate(p3)
deallocate(p4)
deallocate(host_p0)
end program
