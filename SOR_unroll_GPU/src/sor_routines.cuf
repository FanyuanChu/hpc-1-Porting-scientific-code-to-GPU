! sor_routines.cuf
module sor_routines
use cudafor
use sor_params
contains

attributes(global) subroutine sor_kernel(p0,p1,rhs)
    use sor_params
    real, dimension(:,:,:), device :: p0, p1, rhs
    integer :: i, j, k

    i = blockIdx%x*blockDim%x + threadIdx%x
    j = blockIdx%y*blockDim%y + threadIdx%y
    k = blockIdx%z*blockDim%z + threadIdx%z

    if (i >= 0 .and. i <= im+1 .and. j >= 0 .and. j <= jm+1 .and. k >= 0 .and. k <= km+1) then
        ! assume i=x =  west to east , y=j=south to north, k=z = vertical
        if (i==im+1) then
        ! circular
        ! i=im+1
        p1(i,j,k) = p0(i-im,j,k)
        else if (i==0) then
        ! i=0
        ! circular
        p1(i,j,k) = p0(i+im,j,k)
        else if (j==jm+1) then
        ! open
        ! j = jm+1
        p1(i,j,k)=p0(i-1,j,k)
        else if (j==0) then
        ! fixed
        ! j = 0
        ! We keep the original values
            p1(i,j,k)=p0(i,j,k)
        else if (k==0) then
            p1(i,j,k)=p0(i,j,k)
        else if (k==km+1) then
            p1(i,j,k)=p0(i,j,k)
        else
        ! the core
        ! The actual SOR expression
            p1(i,j,k) = p0(i,j,k) + omega*(cn1 *(cn2l*p0(i+1,j,k) + &
                cn2s*p0(i-1,j,k) +cn3l*p0(i,j+1,k) + &
                cn3s*p0(i,j-1,k) +cn4l*p0(i,j,k+1) + &
                cn4s*p0(i,j,k-1) -rhs(i,j,k))-p0(i,j,k))
        end if
    end if

end subroutine sor_kernel

subroutine sor(p0,p1,rhs,gridDim,blockDim)
    use sor_params    
    real, dimension(:,:,:), device :: p0
    real, dimension(:,:,:), device :: p1
    real, dimension(:,:,:), device :: rhs 
    integer, dimension(3) :: gridDim, blockDim

    call sor_kernel<<<gridDim, blockDim>>>(p0, p1, rhs)
end subroutine sor

end module sor_routines
